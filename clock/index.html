<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Clock</title>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #Canvas {
        width: 100% !important;
        height: 100vh !important;
        background: linear-gradient(135deg, #000000 0%, #0d1421 30%, #1a2332 60%, #0d1421 90%, #000000 100%),
                    radial-gradient(ellipse at center, rgba(40, 60, 80, 0.3) 0%, transparent 70%),
                    radial-gradient(circle at 30% 70%, rgba(25, 25, 25, 0.8) 0%, transparent 40%);
        background-size: 100% 100%, 800px 600px, 500px 500px;
        background-attachment: fixed;
      }
      canvas {
        width: 100% !important;
        height: 100vh !important;        
      }
    </style>
  </head>
  <body>
    <main>
      <div id="Canvas">
        <canvas
          id="renderCanvasList" 
          >
        </canvas>
      </div>
    </main>  
    <script type="text/javascript">

      // フォトギャラリー一覧・詳細
      class Carousel {
        constructor() {
          this.degree();
          this.bannerlist();
          this.createScene();
        }
        degree(degrees) {
          // 度数を取得
          switch(true) {
            case degrees !== undefined:
              return degrees * (Math.PI / 180);
              break;
            default:
              return null;
              break;
          }
        }
        async bannerlist() {
          // バナーリストを表示
          const canvasblog = document.getElementById('renderCanvasList');
          const engine = new BABYLON.Engine(canvasblog);  
          const scene = await this.createScene(this.degree, engine, canvasblog);
          engine.runRenderLoop(() => {
            scene.render();
          });
          window.addEventListener('resize', () => {
            engine.resize();
          });
        }
        async createScene(degree, engine, canvasblog) {
          // シーンを作成
          switch(true) {
            case !( degree == undefined ):   
                // シーンを作成
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0,0,0,0); 

                // カメラを作成
                const camera = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 15, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvasblog, true);  

                // ライトを作成
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
                light.diffuse = new BABYLON.Color3(1, 1, 1);
                light.specular = new BABYLON.Color3(1, 1, 1);
                light.groundColor = new BABYLON.Color3(1, 1, 1);

                // リファクタリング後：設定駆動アプローチ
                let fontDataCache = null;
                const clockRings = [
                  { name: 'munute', node: null, yPosition: -2, yPosition_split: -1.85, numbers: Array.from({ length: 60 }, (_, i) => {
                    const pos = (60 - i) % 60;
                    return pos % 5 === 0 ? String(pos) : '.';
                  }), rotationSpeed: 60000 },    // 60秒で1周 (0,·,·,·,·,55,·,·,·,·,50...)
                  { name: 'hours', node: null, yPosition: 0, yPosition_split: 0.15, numbers: Array.from({ length: 60 }, (_, i) => {
                    const pos = (60 - i) % 60;
                    return pos % 5 === 0 ? String(pos) : '.';
                  }), rotationSpeed: 3600000 },   // 1時間で1周 (0,·,·,·,·,55,·,·,·,·,50...)
                  { name: 'hulfday', node: null, yPosition: 2.3, yPosition_split: 2.45, numbers: Array.from({ length: 60 }, (_, i) => {
                    const pos = (60 - i) % 60;
                    if (pos % 5 === 0) {
                      const hourValue = Math.floor(pos / 5);
                      return String(hourValue === 0 ? 12 : hourValue);
                    } else {
                      return '.';
                    }
                  }), rotationSpeed: 43200000 }  // 12時間で1周 (12,.,.,.,.,11,.,.,.,.,10...)
                ];

                // ノードの作成
                clockRings.forEach((ring, ringIndex) => {
                  ring.node = new BABYLON.TransformNode(`rotatingNode${ringIndex}`, scene);
                });

                // Earcutライブラリの設定
                if (typeof earcut !== 'undefined' && BABYLON.PolygonMeshBuilder) {
                  BABYLON.PolygonMeshBuilder.prototype.bjsEarcut = earcut;
                }

                // テキスト作成関数
                const createTextMesh = async (name, value, index, numbers, parentNode, yPosition, yPosition_split) => {

                  // フォントデータを毎回読み込み（awaitエラー回避のため）
                  if (!fontDataCache) {
                    const fontResponse = await fetch("https://assets.babylonjs.com/fonts/Droid Sans_Regular.json");
                    fontDataCache = await fontResponse.json();
                  }
                  const letterCount = 10;
                  const step = 1 / letterCount;

                  const myText = BABYLON.MeshBuilder.CreateText("myText", String(value), fontDataCache, {
                      size: 0.35,
                      resolution: 5, 
                      depth: .2,
                      perLetterFaceUV: (index) => {
                          const startX = index * step;
                          return [
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                          ];
                      }
                  });
                

                  myText.rotation.y = degree(index * (360 / numbers.length));
                  
                  // Y座標の設定：数字か点かで高さを変える
                  const isNumber = (name === 'hulfday' && value !== '.') || (name !== 'hulfday' && !isNaN(value) && value % 5 === 0);
                  myText.position.y = isNumber ? yPosition : yPosition_split;
                  
                  // X,Z座標の設定
                  const angle = degree(index * (360 / numbers.length));
                  const radius = numbers.length / (3.4 * 5);
                  myText.position.x = -(radius * Math.sin(angle));
                  myText.position.z = -(radius * Math.cos(angle));

                  // 光沢のある発光マテリアルを適用
                  const mat = new BABYLON.StandardMaterial(`textMat_${value}_${index}`, scene);
                  mat.diffuseColor = new BABYLON.Color3(0.4, 1, 0.4);    // 明るめの黄緑色
                  mat.specularColor = new BABYLON.Color3(0.6, 1, 0.6);   // 黄緑系の光沢
                  mat.specularPower = 32;                                // 光沢の強度
                  mat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.2); // デジタル時計風の発光効果
                  myText.material = mat;

                  myText.parent = parentNode;
                };

                // 各リングを作成
                for (const ring of clockRings) {
                  for (let i = 0; i < ring.numbers.length; i++) {
                    await createTextMesh(ring.name, ring.numbers[i], i, ring.numbers, ring.node, ring.yPosition, ring.yPosition_split);
                  }
                }

                // 現在時刻に基づいて初期位置を設定
                const now = new Date();
                const seconds = now.getSeconds();
                const minutes = now.getMinutes() + seconds / 60;
                const hours = (now.getHours() % 12) + minutes / 60;
                
                // 各リングの初期回転を設定（0が上にある状態から現在時刻の位置へ）
                clockRings[0].node.rotation.y = (2 * Math.PI * seconds) / 60;       // 秒針（正方向）
                clockRings[1].node.rotation.y = (2 * Math.PI * minutes) / 60;       // 分針（正方向）
                clockRings[2].node.rotation.y = (2 * Math.PI * hours) / 12;         // 時針（正方向、12から時計回り）

                // アニメーション
                scene.registerBeforeRender(() => {
                  const deltaTime = scene.getEngine().getDeltaTime();
                  clockRings.forEach(ring => {
                    ring.node.rotation.y += (2 * Math.PI * deltaTime) / ring.rotationSpeed;
                  });
                });

                // 真ん中の円柱を作成
                const cylinderblack = new BABYLON.MeshBuilder.CreateCylinder("cylinder", {height: 6, diameter: 7,tessellation:60});
                      cylinderblack.position.y = .5;
                const cylinderblackmat = new BABYLON.StandardMaterial(`cylinderblackmat`, scene);                
                      cylinderblackmat.diffuseColor = new BABYLON.Color3(0, 0, 0);  // 少し明るい灰色
                      cylinderblackmat.specularColor = new BABYLON.Color3(1, 1, 1);       // 白い光沢
                      cylinderblackmat.specularPower = 10;                                // 光沢の強度
                      cylinderblackmat.emissiveColor = new BABYLON.Color3(0, 0, 0); // 強い発光効果
                      cylinderblackmat.alpha = 1; 
                      cylinderblack.material = cylinderblackmat; 

                // 真ん中の円柱を作成
                const cylinder = new BABYLON.MeshBuilder.CreateCylinder("cylinder", {height: 6, diameter: 7,tessellation:60});
                      cylinder.position.y = .5;
                const cylindermat = new BABYLON.StandardMaterial("cylindermat", scene);
                      cylindermat.diffuseTexture = new BABYLON.VideoTexture("vidtex", "movie.mp4", scene);
                      cylindermat.alpha = 1;
                      cylinder.material = cylindermat;

                // 上部の円柱を作成
                const cylindertop = new BABYLON.MeshBuilder.CreateCylinder("cylindertop", {height: .7, diameter: 8,tessellation:60});
                cylindertop.position.y = 3.8; 

                const cylindertopmat = new BABYLON.StandardMaterial(`cylindertopmat`, scene);                
                cylindertopmat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);  // 少し明るい灰色
                cylindertopmat.specularColor = new BABYLON.Color3(1, 1, 1);       // 白い光沢
                cylindertopmat.specularPower = 8;                                // 光沢の強度
                cylindertopmat.emissiveColor = new BABYLON.Color3(0, 0, 0); // 強い発光効果
                cylindertopmat.alpha = 1; 
                cylindertop.material = cylindertopmat;             
                
                // 下部の円柱を作成                
                const cylinderbottom = cylindertop.clone();
                cylinderbottom.position.y = -3; 

                // 上部のラインを作成
                const cylinderline = new BABYLON.MeshBuilder.CreateCylinder("cylindertop", {height: .05, diameter: 7.1,tessellation:60});
                cylinderline.position.y = 1.3;
                
                // 下部のラインを作成                
                const cylinderline2 = cylinderline.clone();
                cylinderline2.position.y = -.7;

                
                // 60分割の目盛りを作成する関数
                const createClockMarks = (yPosition, suffix) => {
                  for (let i = 0; i < 60; i++) {
                    let height;
                    if (i % 10 === 0) {
                      height = 0.75; // 0, 10, 20, 30, 40, 50分の長い目盛り
                    } else if (i % 5 === 0) {
                      height = 0.5;  // 5, 15, 25, 35, 45, 55分の中間目盛り
                    } else {
                      height = 0.25; // その他の短い目盛り
                    }
                    const clockline_split = BABYLON.MeshBuilder.CreateBox(`clockline_split_${suffix}_${i}`, {
                      height: height, width: .025, depth: .025
                    });
                    
                    clockline_split.rotation.y = degree(i * (360 / 60));
                    clockline_split.position.x = -(48 / 13.5 * Math.sin(degree(i * (360 / 60))));
                    clockline_split.position.y = yPosition;
                    clockline_split.position.z = -(48 / 13.5 * Math.cos(degree(i * (360 / 60))));
                    
                    // マテリアルを追加
                    const splitmat = new BABYLON.StandardMaterial(`splitmat_${suffix}_${i}`, scene);
                    splitmat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                    splitmat.emissiveColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    clockline_split.material = splitmat;
                  }
                };
                
                // 上部と下部の目盛りを作成
                createClockMarks(1.3, 'top');
                createClockMarks(-0.7, 'bottom');

                // 1-48までの時計の線を作成
                for (let i = 0; i < 120; i++) {
                  if( i != 113 && i != 114 && i != 115 && i != 116 && i != 117 && i != 118 && i != 119 && i != 120 && i != 0 && i != 1 && i != 2 && i != 3 && i != 4 && i != 5 && i != 6 && i != 7) {
                    const tube = BABYLON.MeshBuilder.CreateBox(`clockline_${i}`, {height: 6.5, width: .196, depth: .01});                    
                          tube.rotation.y = degree(i * (360 /120));
                          tube.position.x = -(120 / 32 * Math.sin(degree(i * (360 / 120))));
                          tube.position.y = 0.5;
                          tube.position.z = -(120 / 32 * Math.cos(degree(i * (360 / 120))));
                    
                    const tubemat = new BABYLON.StandardMaterial(`tubemat_${i}`, scene);                
                    tubemat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    tubemat.specularColor = new BABYLON.Color3(1, 1, 1);
                    tubemat.specularPower = 8;
                    tubemat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    tubemat.alpha = .9; 
                    tube.material = tubemat;
                  }
                }
                return scene;
              break;
            default:
              break;
          }
        }
      }
      const carousel = new Carousel();
    </script>
  </body>
</html>
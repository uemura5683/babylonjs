<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Clock</title>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #Canvas {
        width: 100% !important;
        height: 100vh !important;
        background-image: radial-gradient(#1a3a1a, #0f1f0f);
      }
      canvas {
        width: 100% !important;
        height: 100vh !important;        
      }
    </style>
  </head>
  <body>
    <main>
      <div class="tw-relative" id="Canvas">
        <canvas
          id="renderCanvasList" 
          >
        </canvas>
      </div>
    </main>  
    <script type="text/javascript">

      // フォトギャラリー一覧・詳細
      class Carousel {
        constructor() {
          this.degree();
          this.bannerlist();
          this.createScene();
        }
        degree(degrees) {
          // 度数を取得
          switch(true) {
            case degrees !== undefined:
              return degrees * (Math.PI / 180);
              break;
            default:
              return null;
              break;
          }
        }
        async bannerlist() {
          // バナーリストを表示
          const canvasblog = document.getElementById('renderCanvasList');
          const engine = new BABYLON.Engine(canvasblog);  
          const scene = await this.createScene(this.degree, engine, canvasblog);
          engine.runRenderLoop(() => {
            scene.render();
          });
          window.addEventListener('resize', () => {
            engine.resize();
          });
        }
        async createScene(degree, engine, canvasblog) {
          // シーンを作成
          switch(true) {
            case !( degree == undefined ):   
                // シーンを作成
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0,0,0,0); 

                // カメラを作成
                const camera = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 15, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvasblog, true);  

                // ライトを作成
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
                light.diffuse = new BABYLON.Color3(1, 1, 1);
                light.specular = new BABYLON.Color3(1, 1, 1);
                light.groundColor = new BABYLON.Color3(1, 1, 1);


                // リファクタリング後：設定駆動アプローチ
                let fontDataCache = null;
                
                const clockRings = [
                  { node: null, yPosition: -2, numbers: Array.from({ length: 12 }, (_, i) => {
                    const value = (12 - i) * 5;
                    return value === 60 ? '0' : String(value);
                  }), rotationSpeed: 60000 },    // 60秒で1周 (0,55,50,10,5)
                  { node: null, yPosition: 0, numbers: Array.from({ length: 12 }, (_, i) => {
                    const value = (12 - i) * 5;
                    return value === 60 ? '0' : String(value);
                  }), rotationSpeed: 3600000 },   // 1時間で1周 (0,55,50,10,5)
                  { node: null, yPosition: 2, numbers: Array.from({ length: 12 }, (_, i) => i + 1).reverse(), rotationSpeed: 43200000 }  // 12時間で1周 (12,11,10...2,1)
                ];

                // ノードの作成
                clockRings.forEach((ring, ringIndex) => {
                  ring.node = new BABYLON.TransformNode(`rotatingNode${ringIndex}`, scene);
                });

                // Earcutライブラリの設定
                if (typeof earcut !== 'undefined' && BABYLON.PolygonMeshBuilder) {
                  BABYLON.PolygonMeshBuilder.prototype.bjsEarcut = earcut;
                }

                // テキスト作成関数
                const createTextMesh = async (value, index, numbers, parentNode, yPosition) => {
                  // フォントデータを毎回読み込み（awaitエラー回避のため）
                  if (!fontDataCache) {
                    const fontResponse = await fetch("https://assets.babylonjs.com/fonts/Droid Sans_Regular.json");
                    fontDataCache = await fontResponse.json();
                  }
                  const letterCount = 10;
                  const step = 1 / letterCount;

                  const myText = BABYLON.MeshBuilder.CreateText("myText", String(value), fontDataCache, {
                      size: 0.7,
                      resolution: 1, 
                      depth: .1,
                      perLetterFaceUV: (index) => {
                          const startX = index * step;
                          return [
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                          ];
                      }
                  });

                  myText.rotation.y = degree(index * (360 / numbers.length));
                  myText.position.x = -(numbers.length / 3.4 * Math.sin(degree(index * (360 / numbers.length))));
                  myText.position.y = yPosition;
                  myText.position.z = -(numbers.length / 3.4 * Math.cos(degree(index * (360 / numbers.length))));

                  // 光沢のある発光マテリアルを適用
                  const mat = new BABYLON.StandardMaterial(`textMat_${value}_${index}`, scene);
                  mat.diffuseColor = new BABYLON.Color3(0.4, 1, 0.4);    // 明るめの黄緑色
                  mat.specularColor = new BABYLON.Color3(0.6, 1, 0.6);   // 黄緑系の光沢
                  mat.specularPower = 32;                                // 光沢の強度
                  mat.emissiveColor = new BABYLON.Color3(0.2, 0.8, 0.2); // デジタル時計風の発光効果
                  myText.material = mat;

                  myText.parent = parentNode;
                };

                // 各リングを作成
                for (const ring of clockRings) {
                  for (let i = 0; i < ring.numbers.length; i++) {
                    await createTextMesh(ring.numbers[i], i, ring.numbers, ring.node, ring.yPosition);
                  }
                }

                // 現在時刻に基づいて初期位置を設定
                const now = new Date();
                const seconds = now.getSeconds();
                const minutes = now.getMinutes() + seconds / 60;
                const hours = (now.getHours() % 12) + minutes / 60;
                
                // 各リングの初期回転を設定（0が上にある状態から現在時刻の位置へ）
                clockRings[0].node.rotation.y = (2 * Math.PI * seconds) / 60;       // 秒針（正方向）
                clockRings[1].node.rotation.y = (2 * Math.PI * minutes) / 60;       // 分針（正方向）
                clockRings[2].node.rotation.y = (2 * Math.PI * hours) / 12;         // 時針（正方向、12から時計回り）

                // アニメーション
                scene.registerBeforeRender(() => {
                  const deltaTime = scene.getEngine().getDeltaTime();
                  clockRings.forEach(ring => {
                    ring.node.rotation.y += (2 * Math.PI * deltaTime) / ring.rotationSpeed;
                  });
                });

                // 真ん中の円柱を作成
                const cylinder = new BABYLON.MeshBuilder.CreateCylinder("cylinder", {height: 6, diameter: 7});
                cylinder.position.y = .5;
                const cylindermat = new BABYLON.StandardMaterial("cylindermat", scene);
                cylindermat.diffuseTexture = new BABYLON.VideoTexture("vidtex", "movie.mp4", scene);
                cylindermat.alpha = 1;
                cylinder.material = cylindermat;

                // 上部の円柱を作成
                const cylindertop = new BABYLON.MeshBuilder.CreateCylinder("cylindertop", {height: .7, diameter: 8});
                cylindertop.position.y = 3.8; 

                const cylindertopmat = new BABYLON.StandardMaterial(`cylindertopmat`, scene);                
                cylindertopmat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);  // 少し明るい灰色
                cylindertopmat.specularColor = new BABYLON.Color3(1, 1, 1);       // 白い光沢
                cylindertopmat.specularPower = 32;                                // 光沢の強度
                cylindertopmat.emissiveColor = new BABYLON.Color3(0, 0, 0); // 強い発光効果
                cylindertopmat.alpha = 1; 
                cylindertop.material = cylindertopmat;             
                
                // 下部の円柱を作成                
                const cylinderbottom = cylindertop.clone();
                cylinderbottom.position.y = -3; 

                // 上部のラインを作成
                const cylinderline = new BABYLON.MeshBuilder.CreateCylinder("cylindertop", {height: .05, diameter: 7.1});
                cylinderline.position.y = 1.3;
                
                // 下部のラインを作成                
                const cylinderline2 = cylinderline.clone();
                cylinderline2.position.y = -.7;

                const clockline = BABYLON.MeshBuilder.CreateBox("clockline", {height: 6, width: .05, depth: .05});
                clockline.position.y = .5;
                clockline.position.z = -3.5;    

                const clocklinemat = new BABYLON.StandardMaterial(`clocklinemat`, scene);                
                clocklinemat.diffuseColor = new BABYLON.Color3(1, 1, 1);  // 少し明るい灰色
                clocklinemat.specularColor = new BABYLON.Color3(0, 0, 0);       // 白い光沢
                clocklinemat.specularPower = 32;                                // 光沢の強度
                clocklinemat.emissiveColor = new BABYLON.Color3(0, 0, 0); // 強い発光効果
                clocklinemat.alpha = 1; 
                clockline.material = clocklinemat;

                // 1-36までの時計の線を作成
                for (let i = 0; i < 48; i++) {
                  const tube = BABYLON.MeshBuilder.CreateBox(`clockline_${i}`, {height: 6.5, width: .48, depth: .01});
                  
                  if( i != 46 && i != 47 && i != 48 && i != 0 && i != 1 && i != 2 ) {
                    tube.rotation.y = degree(i * (360 /48));
                    tube.position.x = -(48 / 13 * Math.sin(degree(i * (360 / 48))));
                    tube.position.y = 0.5;
                    tube.position.z = -(48 / 13 * Math.cos(degree(i * (360 / 48))));
                    
                    const tubemat = new BABYLON.StandardMaterial(`tubemat_${i}`, scene);                
                    tubemat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                    tubemat.specularColor = new BABYLON.Color3(1, 1, 1);
                    tubemat.specularPower = 32;
                    tubemat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                    tubemat.alpha = .9; 
                    tube.material = tubemat;
                  }
                }


                return scene;
              break;
            default:
              break;
          }
        }

      }
      const carousel = new Carousel();

    </script>
  </body>
</html>
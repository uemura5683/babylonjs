<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Clock</title>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #Canvas {
        width: 100% !important;
        height: 100vh !important;
        background-image: radial-gradient(#494067, #030D14);
      }
       canvas {
        width: 100% !important;
        height: 100vh !important;        
      } 
    </style>
  </head>
  <body>
    <main>
      <div class="tw-relative" id="Canvas">
        <canvas
          id="renderCanvasList" 
          data-blog="1,2,3,4,5,6,7,8,9,10,11,12"
          >
        </canvas>
      </div>
    </main>  
    <script type="text/javascript">

      // フォトギャラリー一覧・詳細
      class Carousel {
        constructor() {
          this.degree();
          this.bannerlist();
          this.createScene();
        }
        degree(degrees) {
          // 度数を取得
          switch(true) {
            case degrees !== undefined:
              return degrees * (Math.PI / 180);
              break;
            default:
              return null;
              break;
          }
        }
        bannerlist() {
          // バナーリストを表示
          const canvasblog = document.getElementById('renderCanvasList');
          const engine = new BABYLON.Engine(canvasblog);  
          const scene = this.createScene(this.degree, engine, canvasblog);
          engine.runRenderLoop(() => {
            scene.render();
          });
          window.addEventListener('resize', () => {
            engine.resize();
          });
        }
        createScene(degree, engine, canvasblog) {
          // シーンを作成
          switch(true) {
            case !( degree == undefined ):   
                // シーンを作成
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0,0,0,0); 

                // カメラを作成
                const camera = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 15, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvasblog, true);
                camera.useAutoRotationBehavior = true;
                camera.autoRotationBehavior.idleRotationSpeed = Math.PI * 10 / 180;  

                // ライトを作成
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
                light.diffuse = new BABYLON.Color3(1, 1, 1);
                light.specular = new BABYLON.Color3(1, 1, 1);
                light.groundColor = new BABYLON.Color3(1, 1, 1);

                // ギャラリーリストを作成
                const canvaslist = canvasblog.dataset.blog;
                const canvaslistsplit = canvaslist.split(',');

                canvaslistsplit.forEach(async function( value, index ) {
                  console.log(index);
                  const boxMat = new BABYLON.StandardMaterial("boxMat");

                  // 比率を計算する
                  // Earcutライブラリの設定を確認
                  if (typeof earcut !== 'undefined' && BABYLON.PolygonMeshBuilder) {
                    BABYLON.PolygonMeshBuilder.prototype.bjsEarcut = earcut;
                  }
                  
                  const response = await fetch("https://assets.babylonjs.com/fonts/Droid Sans_Regular.json");
                  const fontData = await response.json();

                  const letterCount = 10;
                  const step = 1 / letterCount;

                  var myText = BABYLON.MeshBuilder.CreateText("myText", value, fontData, {
                      size: 1,
                      resolution: 1, 
                      depth: .1,
                      perLetterFaceUV: (index) => {
                          const startX = index * step;
                          return [
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                          ];
                      }
                  });

                  myText.rotation.y = degree( index * ( 360 / canvaslistsplit.length ) );

                  myText.position.x = - ( canvaslistsplit.length / 1.5 * Math.sin( degree( index * ( 360 / canvaslistsplit.length ) ) ) );
                  myText.position.y = 0;
                  myText.position.z = - ( canvaslistsplit.length / 1.5 * Math.cos( degree( index * ( 360 / canvaslistsplit.length ) ) ) );

                  const mat = new BABYLON.StandardMaterial("mat");
                  mat.diffuseTexture = new BABYLON.VideoTexture("vidtex","movie.mp4", scene);

                  myText.material = mat;

                });
                return scene;
              break;
            default:
              break;
          }
        }

      }
      const carousel = new Carousel();

    </script>
  </body>
</html>
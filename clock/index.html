<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Clock</title>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/materialsLibrary/babylon.gridMaterial.js"></script>
    <script src="https://code.jquery.com/pep/0.4.1/pep.js"></script>
    <script src="https://unpkg.com/earcut@2.2.4/dist/earcut.min.js"></script>
    <style>
      body {
        margin: 0;
      }
      #Canvas {
        width: 100% !important;
        height: 100vh !important;
        background-image: radial-gradient(#494067, #030D14);
      }
      canvas {
        width: 100% !important;
        height: 100vh !important;        
      }
    </style>
  </head>
  <body>
    <main>
      <div class="tw-relative" id="Canvas">
        <canvas
          id="renderCanvasList" 
          >
        </canvas>
      </div>
    </main>  
    <script type="text/javascript">

      // フォトギャラリー一覧・詳細
      class Carousel {
        constructor() {
          this.degree();
          this.bannerlist();
          this.createScene();
        }
        degree(degrees) {
          // 度数を取得
          switch(true) {
            case degrees !== undefined:
              return degrees * (Math.PI / 180);
              break;
            default:
              return null;
              break;
          }
        }
        async bannerlist() {
          // バナーリストを表示
          const canvasblog = document.getElementById('renderCanvasList');
          const engine = new BABYLON.Engine(canvasblog);  
          const scene = await this.createScene(this.degree, engine, canvasblog);
          engine.runRenderLoop(() => {
            scene.render();
          });
          window.addEventListener('resize', () => {
            engine.resize();
          });
        }
        async createScene(degree, engine, canvasblog) {
          // シーンを作成
          switch(true) {
            case !( degree == undefined ):   
                // シーンを作成
                const scene = new BABYLON.Scene(engine);
                scene.clearColor = new BABYLON.Color4(0,0,0,0); 

                // カメラを作成
                const camera = new BABYLON.ArcRotateCamera("camera2", -Math.PI / 2,  Math.PI / 2, 15, BABYLON.Vector3.Zero(), scene);
                camera.attachControl(canvasblog, true);  

                // ライトを作成
                const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0), scene);
                light.diffuse = new BABYLON.Color3(1, 1, 1);
                light.specular = new BABYLON.Color3(1, 1, 1);
                light.groundColor = new BABYLON.Color3(1, 1, 1);


                // リファクタリング後：設定駆動アプローチ
                let fontDataCache = null;
                
                const clockRings = [
                  { node: null, yPosition: -2, numbers: Array.from({ length: 12 }, (_, i) => i + 1).reverse(), rotationSpeed: 60000 },    // 60秒で1周
                  { node: null, yPosition: 0, numbers: Array.from({ length: 12 }, (_, i) => i + 1), rotationSpeed: 3600000 },             // 1時間で1周
                  { node: null, yPosition: 2, numbers: Array.from({ length: 12 }, (_, i) => i + 1), rotationSpeed: 43200000 }             // 12時間で1周
                ];

                // ノードの作成
                clockRings.forEach((ring, ringIndex) => {
                  ring.node = new BABYLON.TransformNode(`rotatingNode${ringIndex}`, scene);
                });

                // Earcutライブラリの設定
                if (typeof earcut !== 'undefined' && BABYLON.PolygonMeshBuilder) {
                  BABYLON.PolygonMeshBuilder.prototype.bjsEarcut = earcut;
                }

                // テキスト作成関数
                const createTextMesh = async (value, index, numbers, parentNode, yPosition) => {
                  // フォントデータを毎回読み込み（awaitエラー回避のため）
                  if (!fontDataCache) {
                    const fontResponse = await fetch("https://assets.babylonjs.com/fonts/Droid Sans_Regular.json");
                    fontDataCache = await fontResponse.json();
                  }
                  const letterCount = 10;
                  const step = 1 / letterCount;

                  const myText = BABYLON.MeshBuilder.CreateText("myText", String(value), fontDataCache, {
                      size: 1,
                      resolution: 1, 
                      depth: .1,
                      perLetterFaceUV: (index) => {
                          const startX = index * step;
                          return [
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                              new BABYLON.Vector4(startX, 0, startX + step, 1),
                          ];
                      }
                  });

                  myText.rotation.y = degree(index * (360 / numbers.length));
                  myText.position.x = -(numbers.length / 3 * Math.sin(degree(index * (360 / numbers.length))));
                  myText.position.y = yPosition;
                  myText.position.z = -(numbers.length / 3 * Math.cos(degree(index * (360 / numbers.length))));

                  const mat = new BABYLON.StandardMaterial("mat");
                  mat.diffuseTexture = new BABYLON.VideoTexture("vidtex", "movie.mp4", scene);
                  myText.material = mat;
                  myText.parent = parentNode;
                };

                // 各リングを作成
                for (const ring of clockRings) {
                  for (let i = 0; i < ring.numbers.length; i++) {
                    await createTextMesh(ring.numbers[i], i, ring.numbers, ring.node, ring.yPosition);
                  }
                }

                // アニメーション
                scene.registerBeforeRender(() => {
                  const deltaTime = scene.getEngine().getDeltaTime();
                  clockRings.forEach(ring => {
                    ring.node.rotation.y += (2 * Math.PI * deltaTime) / ring.rotationSpeed;
                  });
                });

                return scene;
              break;
            default:
              break;
          }
        }

      }
      const carousel = new Carousel();

    </script>
  </body>
</html>